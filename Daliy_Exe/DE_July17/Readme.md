# DE_July17 - 约瑟夫环 - Josephus Circle
#Daliy_Exe

## 题目&分析
### 题目：
1. 一群人围在一起坐成环状（如：N）
2. 从某个编号开始报数（如：K）
3. 数到某个数（如：M）的时候，此人出列，他的下一个人又从1开始报数，数到M的那个人又出列
4. 一直循环，直到所有人出列，约瑟夫环结束，输出出列的人的顺序
    
- - - -
   
~~### 分析1~~
~~	假设 N = 10, 从编号1开始标号（K = 1），数到2数出列 （M = 2），则第一循环后（报数只到队末时），所有位于偶数的人出列，第二圈中，在新的队列中的偶数位置人出列…如此循环知道最后只剩一个人。~~
~~	假设一开始给10个人一个间隔为1递增的编号以表示它目前的位置 x = （1，2，3…10）上述情况下，每次循环的输出结果为：~~
~~		第一圈输出：{2, 4, 6, 8 ,10}，剩下{1, 3, 5, 7, 9}~~
~~		第二圈输出：{3，7}, 剩下{1, 5, 9}~~
~~		第三圈输出：{1, 9}, 剩下{5}~~
~~		第四圈输出:	{5}, 所有人出列完成~~
~~#### 输入输出分析~~
~~	分析每一圈的输入和输出，第一圈的输入是10个人，输出是当前队列偶数位置，第二圈输入是前一圈剩下人的人形成的队列（即第一圈的奇数编号），输出当前队列的在偶数位置的人..如此循环直到所有人出列完成~~
~~#### 规律分析~~
~~	可以观察到，第二圈的输入（位置信息(x2)）与第一圈输入的(x1) 的关系是：~~
 ~~					x2 = 2 * x1 -1 (x2 < N)					1)~~
~~	在第二圈中，如果将x1另外重新进行间隔1的递增编号（形成了一个新的数组），则第三圈的输入(x2)与第二圈的输入(x1)也使得1)式关系成立。~~
~~	可以总结出，第g圈与第g-1圈的输入Xn满足：~~
~~					Xg+1 = 2* Xg + 1	  (Xn < N	)			*2)~~
~~	需要注意的是：当最后输入的个数等于1时，上述的关系不再被满足，可以认为循环报数已经结束。可以直接将此数输出。~~
~~---~~
~~	为了得出一般规律的数学形式，我们需要将考虑不同N和M下的亲情况。~~
~~	接下来假设 N = 11，对于分析1，此时N为奇数，其余数值和分析操作不变。~~

~~### 分析2~~
~~		第一圈输出：{2, 4, 6, 8 ,10}，剩下{1, 3, 5, 7, 9, 11}~~
~~		第二圈输出：{1, 5,  9} 剩下{3, 7, 11}~~
~~		第三圈输出：{3, 11}, 剩下{7}~~
~~		第四圈输出:	{7}, 所有人出列完成~~
~~#### 规律分析~~
~~	可以观察到，分析1的1)式此时不再成立，x2的第n个值与x1的第n个值似乎不再有像1)式简单的数学关系。但x2的第n+1个值与x1的第n个值满足x2 = 2 * x1 + 1。可以假设在这个输出和输出的关系中存在的一种迟滞为1的状态，为了总结出相应的规律，我们将每一圈中每个编号的对应输出为设为F(n),其中n = {1,2,3…11}表示队列中每个人在当前输入(x1)时的对应编号。可以得出~~
~~					Fg+1(n+1) = 2gF(n) + 1					3)~~
~~而分析1中的1)式则可以表示为：~~
~~					Fg+1(n) = 2gF(n) -1						4)~~
~~至此我们得出每圈输入之间在初始输入为奇数3)和偶数4)情况下的关系。~~

~~## 输入输出关系分析~~
~~	根据问题描述，我们最终是要得出N个人从第K个人开始在M报数情况下的出列顺序。事实上，对于每一个循环（每一圈中），队列的人都是按照M间隔顺序输出的，也就是在编号形式确定为间隔为1的递增形式时，每一圈的输出方式都是相同的，接下来分析下，K的改变对3) & 4)式会造成什么改变。~~

# 分析毛线！算了，试试链表！
## 思路
由于每次数到队尾后都要回到队头重新开始，我们不妨创建一个单向的单循环链表

### 链表节点创建
```
// Create one node
JoseNode *CreateNode(int i)
{
    JoseNode *j;
    j = (JoseNode*)malloc(sizeof(JoseNode));
    j->num = i;
    j->next = NULL;
    return j;
}

// Create LinkNode circle
JoseNode *JoseCircle_Init(JoseNode *head, JoseNode *Jnew, int i)
{
    JoseNode *Jpb = head;
    Jnew = CreateNode(i);
    if (head == NULL)
    {     
        head = Jnew;
        head->next = head;
    }
    else
    {
        while(Jpb->next != head)
            Jpb = Jpb->next;
        Jpb->next = Jnew;
        Jnew->next = head;
    }
    return head;      
}
```

### 初始化单项循环链表
```
void Josephus(const int n, const int k)
{
    JoseNode *Jose_head = NULL, *JoseN = NULL, *j = NULL;
    for (int i = 0; i < n; i++)
        Jose_head = JoseCircle_Init(Jose_head, JoseN, i+1);
}
```

### 逻辑分析
在单循环链表中以第M个节点开始进行遍历，遍历到第K-1个节点时，将第K个节点（k-1->next）推出（出列），将第k-1个节点的next指向k+1个节点，同时将第k+1个节点作为新的heade节点继续重复，知道只剩下一个节点没有被推出，此时head->next = head

### 输出结果
```
Push ordre in case n = 10, m = 1, k = 2 is:
2->4->6->8->10->3->7->1->9->5
==============================================================
Push ordre in case n = 20, m = 2, k = 3 is:
3->6->9->12->15->18->1->5->10->14->19->4->11->17->7->16->8->2->13->20
==============================================================
Push ordre in case n = 50, m = 4, k = 6 is:
4->7->10->13->16->19->22->25->28->31->34->37->40->43->46->49->2->6->11->15->20->24->29->33->38->42->47->1->8->14->21->27->35->41->48->5->17->26->36->45->9->23->39->3->30->50->32->18->44->12
==============================================================
```

				

	
 					







