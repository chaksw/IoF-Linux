# 数据结构与算法 - Data Struct & Algorithm
## 数据结构
### 数组、字符串/Array & String
* 优点：最基础的数据结构，能在O(1)的时间里通过下标 (index) 查询某个元素
* 缺点：构建时必须分配一段连续的空间，这样在查询某个元素是否存在时需要遍历整个数组，耗费O(n)的时间（n是数组元素的个数）。

## 算法

### 冒泡排序 - BubbleSort
#### 原理
冒泡排序实现的是将一组数据结构（数组）（即每个数据结构都含有一个同类型或是具有同样实际意义的信息）按照递增或者递减的顺序重新排列的算法。其基本原理是通过不断比较相邻两个数据结构的同类型值大小，找到两个数中较大（较小）的数并将其后移，从而实现在一次循环中找到当前数组中最大（最小）的值，并将该最值下沉（放到数组尾部），然后执行下一次比较循环，直至整个数组满足递增（递减）排序。

#### 实现分析
算法的核心是比较判断以及比较判断执行的次数，比较判断可以通过 if 判断来实现，在 if 条件成立后进行两数的交换，而比较的执行次数从两个角度结合分析得出：
* 为了找到一个数组当中的最值，我们遍历整个数组，假设整个数组长度为 len， 则比较次数为 len - 1。
* 在找最值的过程中，我们会不断将两个数中的最值往后放（下沉），直到 len - 1次比较完成之后，最值会被放在数组的末端，而这个最值就不需要出现在往后的比较中，所以下次的比较次数就是 len - 2，len - 3, len - 4.. 知道最后只剩下两个数的比较 1
所以对于冒泡算法，比较次数为 !(len - 1)

### 代码&测试
```
// 冒泡排序，升序
void bubbleSort(int *array, int len)
{
    int temp = 0;
    // 两次循环，循环次数共 !(len - 1) 次
    for (int i = 1; i < len; i++)
    {
        for (int k = 0; k < (len - i); k++)
        {
            // Compare
            if(array[k] > array[k+1])
            {
                // Swap
                temp = array[k];
                array[k] = array[k+1];
                array[k+1] = temp;
            }
        }
    }
}
```

#### 输入
`int array[] = {1, 2, 3, 7, 3, 4, 5, 3, 9, 8, 2, 7, 5, 9, 8, 7};`

#### 输出
```
array after bubble sort: 
1   2   2   3   3   3   4   5   5   7   7   7   8   8   9   9 
```

